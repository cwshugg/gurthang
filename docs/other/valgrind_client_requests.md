# Valgrind Memcheck Client Requests

I spent some time learning how to use Valgrind's memcheck client requests in
order to fix a memory leak in gurthang's custom mutator module. The leak would
cause AFL++ to be killed by my OS's out-of-memory checking process:

```
[809009.694913] oom-kill:constraint=CONSTRAINT_NONE,nodemask=(null),cpuset=/,mems_allowed=0,global_oom,task_memcg=/,task=afl-fuzz,pid=16567,uid=1000
[809009.694922] Out of memory: Killed process 16567 (afl-fuzz) total-vm:14591556kB, anon-rss:6918256kB, file-rss:0kB, shmem-rss:112kB, UID:1000 pgtables:28580kB oom_score_adj:0eaper: reaped process 16567 (afl-fuzz), now anon-rss:0kB, file-rss:0kB, shmem-rss:112kB
```

My research advisor recommended I look into client requests to debug the issue.
I've written my findings here.

## Getting Familiar

Valgrind's documentation has a small section on **Client Requests**, linked
[here](https://valgrind.org/docs/manual/mc-manual.html#mc-manual.clientreqs).
It looks as though a header file, `memcheck.h`, can be included in your source
code to then drop various C macros to instruct Valgrind what to do.

In particular, I was interested in the `VALGRIND_DO_LEAK_CHECK` macro. This
is described to do an on-demand leak check in the *middle* of execution.
Normally Valgrind does its leak check after the program has exited.

More documentation is listed [here](https://valgrind.org/docs/manual/manual-core-adv.html#manual-core-adv.clientreq)
on the client request system. It mentions to start looking at the header files,
so I went ahead and downloaded the code from Valgrind's
[download page](https://valgrind.org/downloads/).

### `memcheck.h`

Within the unpacked source code, I located the memcheck header file at
`./valgrind_unpacked/memcheck/memcheck.h`. The description for
`VALGRIND_DO_LEAK_CHECK` was clear enough:

```c
/* Do a full memory leak check (like --leak-check=full) mid-execution. */
#define VALGRIND_DO_LEAK_CHECK                                   \
    VALGRIND_DO_CLIENT_REQUEST_STMT(VG_USERREQ__DO_LEAK_CHECK,   \
                                    0, 0, 0, 0, 0)
```

Time to try it!

## Inserting Client Requests

First, I copied out the single `memcheck.h` file and dropped it into its own
directory so I can pass it to my build command via the `-I` switch.

```bash
$ mkdir /path/to/memcheck_include
$ cp ./valgrind_unpacked/memcheck/memcheck.h /path/to/memcheck_include/
$ cp ./valgrind_unpacked/include/* /path/to/memcheck_include/
```

After adding a special "memcheck" rule to my makefile, I dropped the
`VALGRIND_DO_LEAK_CHECK` macro in a single function, to get an idea of how
it works.

```c
size_t afl_custom_fuzz(gurthang_mut_t* mut, char* buff, size_t buff_len,
                       char** outbuff, char* addbuff, size_t addbuff_len,
                       size_t max_len)
{
    #if defined(GURTHANG_MUT_MEMCHECK)
    // periodically perform memory leak checks
    if (mut->fuzz_count % 10000 == 0)
    {
        VALGRIND_PRINTF("GURTHANG_MUT_MEMCHECK: fuzz_count=%lu\n",
                        mut->fuzz_count);
        VALGRIND_DO_LEAK_CHECK;
    }
    mut->fuzz_count++;
    #endif
    
    // ... implementation ...
```
Because AFL++ invokes `afl_custom_fuzz` hundreds of times a second (since
I've told it to *only* use my mutator), I added a counter to only
perform memory checks every once in a while.

## Memory Leaks!

To my relief, I started seeing signs of `definitely lost` bytes in the
periodic valgrind reports generated by the client request code.

After just 21 minutes, 11MB of memory were `definitely lost`. Yikes.
I've discussed each found leak below:

### First Memory Leak

After inserting the client request code, I compiled and ran AFL++. I waited
for a short time, and to my relief, I saw mention of some `definitely lost`
bytes. I've pasted the abbreviated output below:

```
**30796** GURTHANG_MUT_MEMCHECK: fuzz_count=10000
==30796== 7,661 bytes in 47 blocks are definitely lost in loss record 53 of 82
==30796==    at 0x4C33D2F: realloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==30796==    by 0xEF9E55E: realloc_check (utils.c:225)
==30796==    by 0xEF9D496: buffer_capacity_check (buffer.c:21)
==30796==    by 0xEF9D496: buffer_appendn (buffer.c:46)
==30796==    by 0xEF9EE54: comux_cinfo_data_read_buffer (comux.c:469)
==30796==    by 0xEF9A001: afl_custom_fuzz (mutator.c:1091)
==30796==    by 0x129414: fuzz_one_original (afl-fuzz-one.c:1815)
==30796==    by 0x12B874: fuzz_one (afl-fuzz-one.c:5503)
==30796==    by 0x1122B9: main (afl-fuzz.c:2227)

...

**30796** GURTHANG_MUT_MEMCHECK: fuzz_count=20000
==30796== 60,641 bytes in 143 blocks are definitely lost in loss record 59 of 81
==30796==    at 0x4C33D2F: realloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==30796==    by 0xEF9E55E: realloc_check (utils.c:225)
==30796==    by 0xEF9D496: buffer_capacity_check (buffer.c:21)
==30796==    by 0xEF9D496: buffer_appendn (buffer.c:46)
==30796==    by 0xEF9EE54: comux_cinfo_data_read_buffer (comux.c:469)
==30796==    by 0xEF9A001: afl_custom_fuzz (mutator.c:1091)
==30796==    by 0x129414: fuzz_one_original (afl-fuzz-one.c:1815)
==30796==    by 0x12B874: fuzz_one (afl-fuzz-one.c:5503)
==30796==    by 0x1122B9: main (afl-fuzz.c:2227)

...

**30796** GURTHANG_MUT_MEMCHECK: fuzz_count=30000
==30796== 60,641 bytes in 143 blocks are definitely lost in loss record 59 of 81
==30796==    at 0x4C33D2F: realloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==30796==    by 0xEF9E55E: realloc_check (utils.c:225)
==30796==    by 0xEF9D496: buffer_capacity_check (buffer.c:21)
==30796==    by 0xEF9D496: buffer_appendn (buffer.c:46)
==30796==    by 0xEF9EE54: comux_cinfo_data_read_buffer (comux.c:469)
==30796==    by 0xEF9A001: afl_custom_fuzz (mutator.c:1091)
==30796==    by 0x129414: fuzz_one_original (afl-fuzz-one.c:1815)
==30796==    by 0x12B874: fuzz_one (afl-fuzz-one.c:5503)
==30796==    by 0x1122B9: main (afl-fuzz.c:2227)

...

**30796** GURTHANG_MUT_MEMCHECK: fuzz_count=60000
==30796== 638,673 bytes in 234 blocks are definitely lost in loss record 66 of 81
==30796==    at 0x4C33D2F: realloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==30796==    by 0xEF9E55E: realloc_check (utils.c:225)
==30796==    by 0xEF9D496: buffer_capacity_check (buffer.c:21)
==30796==    by 0xEF9D496: buffer_appendn (buffer.c:46)
==30796==    by 0xEF9EE54: comux_cinfo_data_read_buffer (comux.c:469)
==30796==    by 0xEF9A001: afl_custom_fuzz (mutator.c:1091)
==30796==    by 0x129414: fuzz_one_original (afl-fuzz-one.c:1815)
==30796==    by 0x12B874: fuzz_one (afl-fuzz-one.c:5503)
==30796==    by 0x1122B9: main (afl-fuzz.c:2227)

...

**30796** GURTHANG_MUT_MEMCHECK: fuzz_count=140000
==30796== 4,860,422 bytes in 4,334 blocks are definitely lost in loss record 72 of 82
==30796==    at 0x4C33D2F: realloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==30796==    by 0xEF9E55E: realloc_check (utils.c:225)
==30796==    by 0xEF9D496: buffer_capacity_check (buffer.c:21)
==30796==    by 0xEF9D496: buffer_appendn (buffer.c:46)
==30796==    by 0xEF9EE54: comux_cinfo_data_read_buffer (comux.c:469)
==30796==    by 0xEF9A001: afl_custom_fuzz (mutator.c:1091)
==30796==    by 0x129414: fuzz_one_original (afl-fuzz-one.c:1815)
==30796==    by 0x12B874: fuzz_one (afl-fuzz-one.c:5503)
==30796==    by 0x1122B9: main (afl-fuzz.c:2227)
```

This leak, mentioned multiple times across the leak reports (with an increasing
leak size!), all points to a call to `comux_cinfo_data_read_buffer`, a function
I wrote that reads bytes from a buffer and saves them to the heap. This one
was a relatively quick fix - one branch in my code failed to free the memory
copied to the heap.

### Second Memory Leak

After a while, I started to see another `definitely lost` leak:

```
**30796** GURTHANG_MUT_MEMCHECK: fuzz_count=170000
==30796== 5,114 bytes in 258 blocks are definitely lost in loss record 48 of 83
==30796==    at 0x4C31A3F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==30796==    by 0x4C33D84: realloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==30796==    by 0xEF9E55E: realloc_check (utils.c:225)
==30796==    by 0xEF9D496: buffer_capacity_check (buffer.c:21)
==30796==    by 0xEF9D496: buffer_appendn (buffer.c:46)
==30796==    by 0xEF9C7F1: __gurthang_mut_mutate_cinfo_split (mutator.c:575)
==30796==    by 0xEF9A58C: __gurthang_mut_mutate_cinfos (mutator.c:878)
==30796==    by 0xEF9A58C: afl_custom_fuzz (mutator.c:1111)
==30796==    by 0x129414: fuzz_one_original (afl-fuzz-one.c:1815)
==30796==    by 0x12B874: fuzz_one (afl-fuzz-one.c:5503)
==30796==    by 0x1122B9: main (afl-fuzz.c:2227)

...

**30796** GURTHANG_MUT_MEMCHECK: fuzz_count=180000
==30796== 22,602 bytes in 299 blocks are definitely lost in loss record 54 of 83
==30796==    at 0x4C31A3F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==30796==    by 0x4C33D84: realloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==30796==    by 0xEF9E55E: realloc_check (utils.c:225)
==30796==    by 0xEF9D496: buffer_capacity_check (buffer.c:21)
==30796==    by 0xEF9D496: buffer_appendn (buffer.c:46)
==30796==    by 0xEF9C7F1: __gurthang_mut_mutate_cinfo_split (mutator.c:575)
==30796==    by 0xEF9A58C: __gurthang_mut_mutate_cinfos (mutator.c:878)
==30796==    by 0xEF9A58C: afl_custom_fuzz (mutator.c:1111)
==30796==    by 0x129414: fuzz_one_original (afl-fuzz-one.c:1815)
==30796==    by 0x12B874: fuzz_one (afl-fuzz-one.c:5503)
==30796==    by 0x1122B9: main (afl-fuzz.c:2227)

...

**30796** GURTHANG_MUT_MEMCHECK: fuzz_count=290000
==30796== 22,602 bytes in 299 blocks are definitely lost in loss record 54 of 83
==30796==    at 0x4C31A3F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==30796==    by 0x4C33D84: realloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==30796==    by 0xEF9E55E: realloc_check (utils.c:225)
==30796==    by 0xEF9D496: buffer_capacity_check (buffer.c:21)
==30796==    by 0xEF9D496: buffer_appendn (buffer.c:46)
==30796==    by 0xEF9C7F1: __gurthang_mut_mutate_cinfo_split (mutator.c:575)
==30796==    by 0xEF9A58C: __gurthang_mut_mutate_cinfos (mutator.c:878)
==30796==    by 0xEF9A58C: afl_custom_fuzz (mutator.c:1111)
==30796==    by 0x129414: fuzz_one_original (afl-fuzz-one.c:1815)
==30796==    by 0x12B874: fuzz_one (afl-fuzz-one.c:5503)
==30796==    by 0x1122B9: main (afl-fuzz.c:2227)
```

This one is a little more rare, but it showed up a few times across the
periodic checks. The leak involves one of the mutator's strategies: splitting
a comux chunk into two chunks.

This one was a little harder to find the true source of, so I attempted to
utilize the `VALGRIND_COUNT_LEAKS` macro to let my mutator detect when more
memory had been leaked:

```c
/* Return number of leaked, dubious, reachable and suppressed bytes found by
   all previous leak checks.  They must be lvalues.  */
#define VALGRIND_COUNT_LEAKS(leaked, dubious, reachable, suppressed)     \
   /* For safety on 64-bit platforms we assign the results to private
      unsigned long variables, then assign these to the lvalues the user
      specified, which works no matter what type 'leaked', 'dubious', etc
      are.  We also initialise '_qzz_leaked', etc because
      VG_USERREQ__COUNT_LEAKS doesn't mark the values returned as
      defined. */                                                        \
   {                                                                     \
    unsigned long _qzz_leaked    = 0, _qzz_dubious    = 0;               \
    unsigned long _qzz_reachable = 0, _qzz_suppressed = 0;               \
    VALGRIND_DO_CLIENT_REQUEST_STMT(                                     \
                               VG_USERREQ__COUNT_LEAKS,                  \
                               &_qzz_leaked, &_qzz_dubious,              \
                               &_qzz_reachable, &_qzz_suppressed, 0);    \
    leaked     = _qzz_leaked;                                            \
    dubious    = _qzz_dubious;                                           \
    reachable  = _qzz_reachable;                                         \
    suppressed = _qzz_suppressed;                                        \
   }
```

Which turned me earlier Valgrind request code into this:

```c
size_t afl_custom_fuzz(gurthang_mut_t* mut, char* buff, size_t buff_len,
                       char** outbuff, char* addbuff, size_t addbuff_len,
                       size_t max_len)
{
    #if defined(GURTHANG_MUT_MEMCHECK)
    // periodically perform memory leak checks
    if (mut->fuzz_count % 10000 == 0)
    {
        VALGRIND_PRINTF("GURTHANG_MUT_MEMCHECK: fuzz_count=%lu\n",
                        mut->fuzz_count);
        VALGRIND_DO_LEAK_CHECK;

        // retrieve the latest count of leaked bytes
        unsigned long leaked = 0;
        unsigned long possibly = 0;
        unsigned long reachable = 0;
        unsigned long suppressed = 0;
        VALGRIND_COUNT_LEAKS(leaked, possibly, reachable, suppressed);
        mut->total_leaked = leaked;
        VALGRIND_PRINTF("GURTHANG_MUT_MEMCHECK: "
                        "[leaked=%lu, possibly=%lu, reachable=%lu, suppressed=%lu]\n",
                        leaked, possibly, reachable, suppressed);
    }
    mut->fuzz_count++;
    #endif

    // ... implementation ...
```

This was pretty cool, although I didn't wind up using `VALGRIND_COUNT_LEAKS`
to solve my problem. Instead, I wound up making use of a few `VALGRIND_PRINTF`
calls and some GDB analysis to discover another edge case in which I wasn't
freeing up memory.

## Conclusions

While I didn't explore all of the client-request macros provided by Valgrind,
I still solved my problems with `VALGRIND_DO_LEAK_CHECK`, `VALGRIND_PRINTF`,
and `VALGRIND_COUNT_LEAKS`. Hunting down these bugs would have been a nightmare
without it.

